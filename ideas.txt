
2. implement quarternion math and use it for rotations in 3d
    . struct with w, x, y, z attributes and print, size, etc methods
    . allows to get otations about any axis without doing 7 matrix multiplications just for 
      1 rotation about a given axis
    . quarternion to 4Ã—4 matrix conversion
    . euler angle conversion?
4. draw circle (kinda bad way) (doing this using lines is better ig)
    . using unit vector, rotation vector, 2pi*r instead of drawing points at distance r from centre
    . or maybe draw using lines
    . or some better algorithm
    . create the siney circle (circle around y, with y += sin(angle) angle is variable)
5. clipping
    . either clip before the rotation cum projection matrix, or clip in the projected space
      . to clip before, we can create moving player objects with fixed six planes (essentially just
        some normal vectors and some points)
      . though clipping after projection has an advantage of having simpler normals to planes
6. world is a array of vertices
    . every object is a array of pointer to triangles
      . every triangle is a array of pointer to vertices
7. managing objects
    . create an interface with draw()
      . put all objects in an array in the interface
      . loop over them to draw each
    . manage another rotation matrix connected to each objest that defines its rotation per frame
      . if objects rotates continuously, the matrix is not identity matrix
      . if matrix stops rotation after some time, it the matrix changes into identity matrix after 
        after some time
    . to rotate everything around player, a single camera matrix is multiplied with every coord
      perhaps save it with the player
8. gravitation simulation 3d
9. for temporary z-buffer thing
    . take average of the coords of triangle
    . sort triangles acc to z after projection
    . draw them in this order
10. depth buffer thing
    . create a [][]float of the suze of no. of pixels with some default value (-inf)
    . while going through all pixels of a triangle,
      . calculate the z value at that point in triangle
        and if its higher than the current value, replace it with the new value and draw the pixel
11. draw torus
    . spin circle around a axis and store the vertices
    . connect vertices into triangles


. remember to
    . change printing to something smarter
      . a := []rune("xxxxxxx") fmt.Println(string(a)) . this works!
    /. try: big scrDist and objects within that and origin(closer to screen)
          - cant really do this cuz i got fov now.
    . try: 1/(z-scrDist) and scrDist/(z+scrDist) in projectP3d
    . make a demo showing fov change with time
    . add roll to camera.go
    /. fix line() in projection.go - /length can cause issues
    . figure out what the extra cot was in projection now in transform()
    . try adding sin and stuff to the sphere coordinates
      . that coding train vid (wierd shapes from spheres)
    . add w1 to the new triangle rasterization (fill())
      . it would add a matScalar but save 2 matSub and 1 matAdd
      . basically use the barycentric coords w1, w2, w3 instead of just 2
    . try making the rasterisation more accurate by making dw smaller when close to the limit
    . convert the inTriangle() func to a tri.method() (only uses camtices)
      . though the func is kinda redundant now so idk
    . add panic quit Q to controls
    

. plan
    . improve the shading textures by trial and error
    . clip (triangle.fill())
      . the parts of triangles outside the screen limit
      . clip in z
        . -0.001 to -1 (idk lower(towards 0) limit)
    . profiling to see whats slowing down
    . add the wait delay in parallel somehow

. bugs
    . rotation not accurate
      . cube rotation along diagonal
    . random characters appear randomly
      . its most likely an issue with ncurses + ubu + termux
    /. half of the triangles in sphere arent created yet
    . out of place bright/dark characters appear on the bottom of sphere