/1. for objects
    . make class of diff objects, with class.draw() for drawing,
      class.rotate(), etc
        eg( 
          cube:
            centre = ..
            side = ..
            coords = (in terms of centre and side. so that changing centre translates the cube)
            // if coords not like above, we can try translate() or just 4 by 4 matrix in rotate()
          )
2. implement quarternion math and use it for rotations in 3d
    . struct with w, x, y, z attributes and print, size, etc methods
    . allows to get otations about any axis without doing 7 matrix multiplications just for 
      1 rotation about a given axis
    . quarternion to 4Ã—4 matrix conversion
    . euler angle conversion?
/3. projection matrix for projecting to 2d and depth buffer
4. draw circle
    . using unit vector, rotation vector, 2pi*r instead of drawing points at distance r from centre
    . or maybe draw using lines
    . or some better algorithm
    . create the siney circle (circle around y, with y += sin(angle) angle is variable)
5. clipping
    . either clip before the rotation cum projection matrix, or clip in the projected space
      . to clip before, we can create moving player objects with fixed six planes (essentially just
        some normal vectors and some points)
      . though clipping after projection has an advantage of having simpler normals to planes
6. managing objects
    . create an interface with draw()
      . put all objects in an array in the interface
      . loop over them to draw each
    . manage another rotation matrix connected to each objest that defines its rotation per frame
      . if objects rotates continuously, the matrix is not identity matrix
      . if matrix stops rotation after some time, it the matrix changes into identity matrix after 
        after some time
    . to rotate everything around player, a single camera matrix is multiplied with every coord
      perhaps save it with the player
7. gravitation simulation 3d
8. for temporary z-buffer thing
    . take average of the coords of triangle
    . sort triangles acc to z after projection
    . draw them in this order


. remember to
    /. change the printing method, so that points outside the screen dont crash the program
    . change board to [][]
    . change printing to something smarter
      . a := []rune("xxxxxxx") fmt.Println(string(a)) . this works!
    /. try: big scrDist and objects within that and origin(closer to screen)
          - cant really do this cuz i got fov now.
    . try: 1/(z-scrDist) and scrDist/(z+scrDist) in projectP3d
    . make a demo showing fov change with time
    /. rotation is slightly borken (not accurate)
      /. i dont understand why
    . fix camtices in world.go
    . add roll to camera.go
    /. fix line() in projection.go - /length can cause issues
    . move the dividing by w in tri.transform() from tri.fill()
    

. plan
    /. projection matrix instead of the current methods
    . profiling to see whats slowing down
    . clipping the bounding boxes of triangles to the screen limit
    . add the wait delay in parallel somehow
    . dot product with normal defines the brightness

. bugs
    . rotation not accurate
      . cube rotation along diagonal
    /. triangle.fill() or inTriangle() is broken
      /. triangle disappears even with the dot product test disabled
    /. the dot product test in triangle is broken
      /. maybe cuz of bad campos and camdir
        /. move up/down broken
    /. point() draw() line() and stuff broken cuz projection mat
    /. rotation around cube seems broken
    /. the projection of cube also seems broken
      /. maybe cuz of the extra cot